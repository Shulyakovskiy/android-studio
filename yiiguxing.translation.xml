<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1714359208766" />
  </component>
  <component name="Translation.States">
    <option name="translationDialogCollapseDictViewer" value="false" />
    <option name="translationDialogHeight" value="543" />
    <option name="translationDialogLocationX" value="474" />
    <option name="translationDialogLocationY" value="243" />
    <option name="translationDialogWidth" value="970" />
    <histories>
      <item value="  /// The application is not currently visible to the user, and not responding&#10;  /// to user input.&#10;  ///&#10;  /// When the application is in this state, the engine will not call the&#10;  /// [PlatformDispatcher.onBeginFrame] and [PlatformDispatcher.onDrawFrame]&#10;  /// callbacks.&#10;  ///&#10;  /// This state is only entered on iOS and Android." />
      <item value="  /// All views of an application are hidden, either because the application is&#10;  /// about to be paused (on iOS and Android), or because it has been minimized&#10;  /// or placed on a desktop that is no longer visible (on non-web desktop), or&#10;  /// is running in a window or tab that is no longer visible (on the web).&#10;  ///&#10;  /// On iOS and Android, in order to keep the state machine the same on all&#10;  /// platforms, a transition to this state is synthesized before the [paused]&#10;  /// state is entered when coming from [inactive], and before the [inactive]&#10;  /// state is entered when coming from [paused]. This allows cross-platform&#10;  /// implementations that want to know when an app is conceptually &quot;hidden&quot; to&#10;  /// only write one handler." />
      <item value="старт" />
      <item value="заголовок" />
      <item value="pfujkjdjr" />
      <item value="Выбрать можно только один таймер" />
      <item value="Whether to maintain space for where the widget would have been.&#10;To set this, maintainAnimation and maintainState must also be set.&#10;Maintaining the size when the widget is not visible is not notably more expensive than just keeping animations running without maintaining the size, and may in some circumstances be slightly cheaper if the subtree is simple and the visible property is frequently toggled, since it avoids triggering a layout change when the visible property is toggled. If the child subtree is not trivial then it is significantly cheaper to not even keep the state (see maintainState).&#10;If this property is false, Offstage is used.&#10;If this property is false, then maintainSemantics and maintainInteractivity must also be false.&#10;Dynamically changing this value may cause the current state of the subtree to be lost (and a new instance of the subtree, with new State objects, to be immediately created if visible is true).&#10;See also:" />
      <item value="Control whether the given child is visible.&#10;The maintainSemantics and maintainInteractivity arguments can only be set if maintainSize is set.&#10;The maintainSize argument can only be set if maintainAnimation is set.&#10;The maintainAnimation argument can only be set if maintainState is set." />
      <item value="занимает" />
      <item value="pfybvftn" />
      <item value="удалить стрелка" />
      <item value="удалить" />
      <item value="elfkbnm" />
      <item value="elfkbn" />
      <item value="Удалить стрелка" />
      <item value="│ At this point the state of the widget's element tree is no longer stable.&#10;[        ] I/flutter ( 7338): │ To safely refer to a widget's ancestor in its dispose() method, save a reference to the ancestor by calling dependOnInheritedWidgetOfExactType() in the widget's didChangeDependencies() method." />
      <item value="Название тренировки" />
      <item value="ошибочные" />
      <item value="jошибочные" />
      <item value="jib,jxyst" />
      <item value="черновик" />
      <item value="xthyjdbr" />
      <item value="У Вас нет созданных тренировок" />
      <item value="Тренировки" />
      <item value="Для загрузки фотографий" />
      <item value="Выберите источник" />
      <item value="Типы файлов *.jpg, *.png, до 5 мб" />
      <item value="deffered" />
      <item value="отложенная" />
      <item value="jnkj;tyyfz" />
      <item value="jnkj" />
      <item value="This Router&lt;Object&gt; widget cannot be marked as needing to build because the framework is already in the process of building widgets. A widget can be marked as needing to be built during the build phase only if one of its ancestors is currently building. This exception is allowed because the framework builds parent widgets before children, which means a dirty descendant will always be built. Otherwise, the framework might not visit this widget during this build phase." />
      <item value="Информация не заполнена&quot;" />
      <item value="Мое оружие" />
      <item value="У вас нет добавленного оружия&quot;" />
      <item value="Оружейная" />
      <item value="Удалить" />
      <item value="Нельзя добавить больше 3-х изображений, удалите для добавления новых." />
      <item value="Галерея" />
      <item value="Фото оружия, лицензия и т.п {}До 3-х файлов, *.jpg, *.png, до 5 мб" />
      <item value="Серийный номер" />
      <item value="Год выпуска" />
      <item value="название" />
      <item value="yfpdfybt" />
      <item value="Введите данные об оружи" />
      <item value="Информация об оружии" />
      <item value="Удалить оружие" />
      <item value="nhandled Exception: Unsupported operation: ObjectBox platform-specific library not compatible: is 0.15.2 (3.1.2-2022-02-15 (admin)), expected 0.21.0 (3.8.0-2024-02-13) or newer. For Flutter, check if the ObjectBox Pod or objectbox-android-objectbrowser need to be updated. For Dart, re-run the install.sh script to download the latest version" />
      <item value="Subscribes to a Future and returns its current state as an AsyncSnapshot.&#10;preserveState determines if the current value should be preserved when changing the Future instance.&#10;The Future needs to be created outside of useFuture. If the Future is created inside useFuture, then, every time the build method gets called, the Future will be called again. One way to create the Future outside of useFuture is by using useMemoized." />
      <item value="reates a fixed-length scrollable linear array of list &quot;items&quot; separated by list item &quot;separators&quot;.&#10;This constructor is appropriate for list views with a large number of item and separator children because the builders are only called for the children that are actually visible.&#10;The itemBuilder callback will be called with indices greater than or equal to zero and less than itemCount.&#10;Separators only appear between list items: separator 0 appears after item 0 and the last separator appears before the last item.&#10;The separatorBuilder callback will be called with indices greater than or equal to zero and less than itemCount - 1.&#10;The itemBuilder and separatorBuilder callbacks should always actually create widget instances when called. Avoid using a builder that returns a previously-constructed widget; if the list view's children are created in advance, or all at once when the ListView itself is created, it is more efficient to use the ListView constructor.&#10;It is legal for itemBuilder to return null. If it does, the scroll view will stop calling itemBuilder, even if it has yet to reach itemCount. By returning null, the ScrollPosition.maxScrollExtent will not be accurate unless the user has reached the end of the ScrollView. This can also cause the Scrollbar to grow as the user scrolls.&#10;For more accurate ScrollMetrics, consider specifying itemCount.&#10;The findChildIndexCallback corresponds to the SliverChildBuilderDelegate.findChildIndexCallback property. If null, a child widget may not map to its existing RenderObject when the order of children returned from the children builder changes. This may result in state-loss. This callback needs to be implemented if the order of the children may change at a later time." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="BULGARIAN" value="1" />
        <entry key="ENGLISH" value="29" />
        <entry key="RUSSIAN" value="88" />
      </map>
    </option>
  </component>
</application>